#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
DailyCheck Dashboard - Utilities & Test Data Generator
Утилиты для дашборда и генератор тестовых данных

Автор: AI Assistant  
Версия: 4.0.0
Дата: 2025-06-10
"""

import json
import random
import uuid
from datetime import datetime, date, timedelta
from pathlib import Path
from typing import Dict, List, Any
import argparse

# ===== ГЕНЕРАТОР ТЕСТОВЫХ ДАННЫХ =====

class TestDataGenerator:
    """Генератор тестовых данных для дашборда"""
    
    # Списки для генерации реалистичных данных
    FIRST_NAMES = [
        "Александр", "Мария", "Сергей", "Анна", "Дмитрий", "Елена", "Михаил", "Ольга",
        "Андрей", "Наталия", "Алексей", "Светлана", "Владимир", "Татьяна", "Николай",
        "Ирина", "Павел", "Юлия", "Артем", "Екатерина", "Максим", "Виктория", "Роман"
    ]
    
    USERNAMES = [
        "productivity_master", "habit_tracker", "goal_crusher", "daily_warrior", 
        "success_seeker", "motivation_hero", "task_ninja", "progress_maker",
        "efficiency_expert", "life_optimizer", "dream_chaser", "habit_builder"
    ]
    
    TASK_TITLES = {
        "health": [
            "Выпить 8 стаканов воды", "Сделать зарядку", "Пройти 10000 шагов",
            "Принять витамины", "Медитировать 10 минут", "Лечь спать до 23:00",
            "Съесть 5 порций овощей", "Сделать растяжку", "Пробежать 30 минут"
        ],
        "work": [
            "Проверить почту", "Выполнить главную задачу", "Провести планирование",
            "Изучить новый материал", "Подготовить отчет", "Провести встречу",
            "Обновить проект", "Ответить на сообщения", "Организовать рабочее место"
        ],
        "learning": [
            "Прочитать 20 страниц", "Изучить 10 новых слов", "Посмотреть TED выступление",
            "Решить задачи по математике", "Изучить урок онлайн", "Написать конспект",
            "Повторить материал", "Сделать упражнения", "Изучить новую технологию"
        ],
        "personal": [
            "Навести порядок дома", "Позвонить родителям", "Записать мысли в дневник",
            "Послушать музыку", "Приготовить здоровую еду", "Провести время с семьей",
            "Заняться хобби", "Прогуляться на природе", "Встретиться с друзьями"
        ],
        "finance": [
            "Проверить расходы", "Отложить деньги", "Изучить инвестиции",
            "Оплатить счета", "Проанализировать бюджет", "Почитать о финансах",
            "Обновить финансовый план", "Сравнить цены", "Оптимизировать расходы"
        ]
    }
    
    ACHIEVEMENTS = [
        "first_task", "streak_3", "streak_7", "tasks_10", "tasks_50", 
        "level_5", "social_butterfly", "early_bird", "perfect_week"
    ]
    
    @classmethod
    def generate_user(cls, user_id: int) -> Dict[str, Any]:
        """Генерация одного пользователя с реалистичными данными"""
        
        # Базовая информация
        first_name = random.choice(cls.FIRST_NAMES)
        username = f"{random.choice(cls.USERNAMES)}_{random.randint(100, 999)}"
        
        # Дата регистрации (от 1 до 365 дней назад)
        days_ago = random.randint(1, 365)
        registration_date = (datetime.now() - timedelta(days=days_ago)).isoformat()
        
        # Статистика
        total_tasks = random.randint(5, 30)
        completed_tasks = random.randint(int(total_tasks * 0.3), int(total_tasks * 0.9))
        current_streak = random.randint(0, 50)
        longest_streak = max(current_streak, random.randint(0, 100))
        level = min(1 + completed_tasks // 10, 15)
        total_xp = completed_tasks * random.randint(15, 35) + level * 50
        
        # Создаем пользователя
        user_data = {
            "user_id": user_id,
            "username": username,
            "first_name": first_name,
            "last_name": None,
            "settings": {
                "timezone": "UTC",
                "language": "ru", 
                "theme": random.choice(["classic", "dark", "nature", "minimal", "colorful"]),
                "daily_reminder_time": f"{random.randint(7, 10):02d}:00",
                "reminder_enabled": True,
                "weekly_stats": True,
                "motivational_messages": True,
                "notification_sound": True,
                "auto_archive_completed": False,
                "ai_chat_enabled": random.choice([True, False]),
                "show_xp": True,
                "show_streaks": True,
                "dry_mode_enabled": random.choice([True, False]),
                "pomodoro_duration": 25,
                "short_break_duration": 5,
                "long_break_duration": 15
            },
            "stats": {
                "total_tasks": total_tasks,
                "completed_tasks": completed_tasks,
                "current_streak": current_streak,
                "longest_streak": longest_streak,
                "total_xp": total_xp,
                "level": level,
                "last_activity": datetime.now().isoformat(),
                "registration_date": registration_date,
                "total_session_time": random.randint(3600, 86400),
                "preferred_time_of_day": random.choice(["morning", "afternoon", "evening"]),
                "tasks_completed_today": random.randint(0, 5),
                "daily_xp_earned": random.randint(0, 150),
                "weekly_goal": random.randint(5, 15),
                "monthly_goal": random.randint(20, 60),
                "dry_days": random.randint(0, 100) if user_data.get("settings", {}).get("dry_mode_enabled") else 0,
                "total_pomodoros": random.randint(0, 500)
            },
            "tasks": {},
            "achievements": random.sample(cls.ACHIEVEMENTS, random.randint(1, 5)),
            "friends": [],
            "reminders": [],
            "notes": f"Заметки пользователя {first_name}",
            "ai_chat_history": [],
            "weekly_goals": {}
        }
        
        # Генерируем задачи
        for i in range(total_tasks):
            task = cls.generate_task(user_id, i)
            user_data["tasks"][task["task_id"]] = task
        
        return user_data
    
    @classmethod 
    def generate_task(cls, user_id: int, task_index: int) -> Dict[str, Any]:
        """Генерация одной задачи"""
        
        category = random.choice(list(cls.TASK_TITLES.keys()))
        title = random.choice(cls.TASK_TITLES[category])
        
        # Дата создания (от 1 до 90 дней назад)
        days_ago = random.randint(1, 90)
        created_at = (datetime.now() - timedelta(days=days_ago)).isoformat()
        
        task = {
            "task_id": str(uuid.uuid4()),
            "user_id": user_id,
            "title": title,
            "description": f"Описание задачи: {title.lower()}",
            "category": category,
            "priority": random.choice(["low", "medium", "high"]),
            "status": random.choice(["active"] * 8 + ["paused", "archived"]),  # 80% активных
            "created_at": created_at,
            "completions": [],
            "subtasks": [],
            "tags": random.sample(["важно", "срочно", "дом", "работа", "здоровье"], random.randint(0, 2)),
            "is_daily": True,
            "reminder_time": None,
            "estimated_time": random.choice([None, 15, 30, 45, 60]),
            "difficulty": random.randint(1, 5)
        }
        
        # Генерируем историю выполнений
        task["completions"] = cls.generate_completions(days_ago)
        
        # Генерируем подзадачи (иногда)
        if random.random() < 0.3:  # 30% задач имеют подзадачи
            task["subtasks"] = cls.generate_subtasks(random.randint(1, 4))
        
        return task
    
    @classmethod
    def generate_completions(cls, days_since_creation: int) -> List[Dict[str, Any]]:
        """Генерация истории выполнений задачи"""
        completions = []
        
        # Генерируем выполнения с реалистичной частотой
        completion_rate = random.uniform(0.3, 0.8)  # От 30% до 80% дней
        
        for i in range(days_since_creation):
            completion_date = (date.today() - timedelta(days=i)).isoformat()
            
            if random.random() < completion_rate:
                completion = {
                    "date": completion_date,
                    "completed": True,
                    "note": random.choice([None, "Выполнено!", "Отлично!", "Было сложно", "Легко"]),
                    "timestamp": (datetime.now() - timedelta(days=i, hours=random.randint(0, 23))).isoformat(),
                    "time_spent": random.choice([None, 15, 30, 45, 60])
                }
                completions.append(completion)
        
        return completions
    
    @classmethod
    def generate_subtasks(cls, count: int) -> List[Dict[str, Any]]:
        """Генерация подзадач"""
        subtasks = []
        
        for i in range(count):
            subtask = {
                "subtask_id": str(uuid.uuid4()),
                "title": f"Подзадача {i + 1}",
                "completed": random.choice([True, False]),
                "created_at": datetime.now().isoformat()
            }
            subtasks.append(subtask)
        
        return subtasks

# ===== УТИЛИТЫ ДАШБОРДА =====

class DashboardUtils:
    """Утилиты для работы с дашбордом"""
    
    @staticmethod
    def validate_data_file(file_path: str) -> bool:
        """Проверка корректности файла данных"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            if not isinstance(data, dict):
                return False
            
            # Проверяем структуру пользователей
            for user_id, user_data in data.items():
                if not isinstance(user_data, dict):
                    return False
                
                required_fields = ["user_id", "settings", "stats", "tasks"]
                for field in required_fields:
                    if field not in user_data:
                        return False
            
            return True
            
        except Exception as e:
            print(f"Ошибка валидации: {e}")
            return False
    
    @staticmethod
    def backup_data(source_file: str, backup_dir: str = "backups") -> str:
        """Создание резервной копии данных"""
        backup_path = Path(backup_dir)
        backup_path.mkdir(exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = backup_path / f"backup_{timestamp}.json"
        
        import shutil
        shutil.copy2(source_file, backup_file)
        
        return str(backup_file)
    
    @staticmethod
    def clean_old_backups(backup_dir: str = "backups", keep_count: int = 10):
        """Удаление старых резервных копий"""
        backup_path = Path(backup_dir)
        
        if not backup_path.exists():
            return
        
        backups = list(backup_path.glob("backup_*.json"))
        backups.sort(key=lambda x: x.stat().st_mtime, reverse=True)
        
        # Удаляем старые бэкапы
        for backup in backups[keep_count:]:
            backup.unlink()
            print(f"Удален старый бэкап: {backup.name}")
    
    @staticmethod
    def optimize_data_file(file_path: str):
        """Оптимизация файла данных"""
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        # Удаляем старые записи выполнений (старше 1 года)
        cutoff_date = date.today() - timedelta(days=365)
        
        for user_data in data.values():
            for task in user_data.get("tasks", {}).values():
                completions = task.get("completions", [])
                filtered_completions = [
                    c for c in completions 
                    if date.fromisoformat(c["date"]) >= cutoff_date
                ]
                task["completions"] = filtered_completions
        
        # Сохраняем оптимизированные данные
        with open(file_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
        
        print(f"Данные оптимизированы: {file_path}")

# ===== CLI ИНТЕРФЕЙС =====

def main():
    """Основная функция CLI"""
    parser = argparse.ArgumentParser(description="DailyCheck Dashboard Utilities")
    
    subparsers = parser.add_subparsers(dest='command', help='Доступные команды')
    
    # Генерация тестовых данных
    gen_parser = subparsers.add_parser('generate', help='Генерация тестовых данных')
    gen_parser.add_argument('--users', type=int, default=10, help='Количество пользователей')
    gen_parser.add_argument('--output', default='test_data.json', help='Файл для сохранения')
    
    # Валидация данных
    val_parser = subparsers.add_parser('validate', help='Проверка данных')
    val_parser.add_argument('file', help='Файл для проверки')
    
    # Создание бэкапа
    backup_parser = subparsers.add_parser('backup', help='Создание бэкапа')
    backup_parser.add_argument('file', help='Файл для бэкапа')
    backup_parser.add_argument('--dir', default='backups', help='Папка для бэкапов')
    
    # Очистка старых бэкапов
    clean_parser = subparsers.add_parser('clean', help='Очистка старых бэкапов')
    clean_parser.add_argument('--dir', default='backups', help='Папка с бэкапами')
    clean_parser.add_argument('--keep', type=int, default=10, help='Сколько оставить')
    
    # Оптимизация данных
    opt_parser = subparsers.add_parser('optimize', help='Оптимизация данных')
    opt_parser.add_argument('file', help='Файл для оптимизации')
    
    args = parser.parse_args()
    
    if args.command == 'generate':
        print(f"🎲 Генерация {args.users} тестовых пользователей...")
        
        test_data = {}
        for i in range(args.users):
            user_id = 1000000 + i
            user_data = TestDataGenerator.generate_user(user_id)
            test_data[str(user_id)] = user_data
            print(f"   ✅ Пользователь {user_id}: {user_data['first_name']}")
        
        # Сохраняем данные
        with open(args.output, 'w', encoding='utf-8') as f:
            json.dump(test_data, f, ensure_ascii=False, indent=2)
        
        print(f"💾 Тестовые данные сохранены: {args.output}")
        print(f"📊 Всего пользователей: {len(test_data)}")
        print(f"📝 Всего задач: {sum(len(u['tasks']) for u in test_data.values())}")
        
    elif args.command == 'validate':
        print(f"🔍 Проверка файла: {args.file}")
        
        if DashboardUtils.validate_data_file(args.file):
            print("✅ Файл корректен")
        else:
            print("❌ Файл содержит ошибки")
    
    elif args.command == 'backup':
        print(f"💾 Создание бэкапа: {args.file}")
        
        backup_file = DashboardUtils.backup_data(args.file, args.dir)
        print(f"✅ Бэкап создан: {backup_file}")
    
    elif args.command == 'clean':
        print(f"🧹 Очистка старых бэкапов в {args.dir}")
        
        DashboardUtils.clean_old_backups(args.dir, args.keep)
        print(f"✅ Оставлено {args.keep} последних бэкапов")
    
    elif args.command == 'optimize':
        print(f"⚡ Оптимизация файла: {args.file}")
        
        # Создаем бэкап перед оптимизацией
        backup_file = DashboardUtils.backup_data(args.file)
        print(f"💾 Бэкап создан: {backup_file}")
        
        DashboardUtils.optimize_data_file(args.file)
        print("✅ Оптимизация завершена")
    
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
